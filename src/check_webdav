#!/usr/bin/env python
##############################################################################
# Copyright (c) Members of the EGEE Collaboration. 2011.
# See http://www.eu-egee.org/partners/ for details on the copyright
# holders.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS
# OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##############################################################################
#
# NAME :        check_webdav_endpoint
#
# DESCRIPTION : Checks the webdav interface to an endpoint
#
# AUTHORS :     Ivan Calvet <ivan.calvet@cern.ch>
#               Georgios Bitzes <georgios.bitzes@cern.ch>
#
##############################################################################

from __future__ import print_function, division, absolute_import

import os
import sys
import time
import pycurl
import ldap
import functools
import argparse
import StringIO
import random
import traceback
import urlparse

__version__ = "0.1"

__MAX_RND__ = 999999999
__TEST_FILENAME__ = "test_webdav_access_"
__TEST_FILE__ = "This is a test file generated by the nagios probe check-webdav from package nagios-plugins-webdav. It is safe to delete.\n"

# Verbosity
V_MINIMAL  = 0
V_EXTENDED = 1
V_DEBUG    = 2
V_ALL      = 3

EX_OK       = 0
EX_WARNING  = 1
EX_CRITICAL = 2
EX_UNKNOWN  = 3

def code_to_str(code):
    if code == EX_CRITICAL:
        return "FAILURE"
    elif code == EX_WARNING:
        return "SLOW"
    elif code == EX_OK:
        return "OK"
    elif code == EX_UNKNOWN:
        return "UNKNOWN"

def http_status_to_explanation(status):
    if status == 404:
        return "file/path not found (are you using an incorrect path?)"
    elif status == 403:
        return "forbidden (are you using a valid certificate?)"
    elif status == 0:
        return "connection failure (service down? SSL not configured properly?)"
    return "status {0}".format(status)

def getargs():
    class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter, argparse.RawTextHelpFormatter):
        pass

    helptext = "Use either --uri or (--hostname, --port, and --path) to specify the target."

    parser = argparse.ArgumentParser(formatter_class=CustomFormatter,
                                     description="Checks the WebDAV capabilities of an endpoint.\n" + helptext,
                                     epilog="The script will return the following exit code:\n"
                                     "\t{0}, if all tests passed\n".format(EX_OK) +
                                     "\t{0}, if all tests passed but some were over the warning threshold\n".format(EX_WARNING) +
                                     "\t{0}, if some tests failed\n".format(EX_CRITICAL) +
                                     "\t{0}, if status is unknown\n".format(EX_UNKNOWN))

    # group = parser.add_mutually_exclusive_group(required=True)
    parser.add_argument('-H', '--hostname', type=str, help="The hostname to query\n")
    parser.add_argument('-u', '--uri', type=str, help="The target URI to test")

    parser.add_argument('-E', '--proxy', type=str, required=True, help="The path to the proxy certificate to use\n")
    parser.add_argument('-p', '--port', type=int, default=443, help="The server port to use\n")
    parser.add_argument('-P', '--path', type=str, help="The target server path to test\n")
    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help="Verbosity levels:\n"
                        " -v   -> display some information about every test\n"
                        " -vv  -> show detailed information about every test\n"
                        " -vvv -> print server responses and headers, only for debugging\n")
    parser.add_argument('--capath', type=str, default="/etc/grid-security/certificates",
                        help="The certificate store to verify host credentials\n")
    parser.add_argument('-w', '--warning', type=int, default=4, help="Sets the warning threshold (seconds)\n")
    parser.add_argument('-t', '--timeout', type=int, default=10, help="Sets the timeout threshold (seconds)\n")
    parser.add_argument('-m', '--metric', type=str, help="The metric prefix under which to publish the results in Nagios.\n"
                        "Results will not be published if it isn't specified.")
    parser.add_argument('-f', '--fqan', type=str, default="", help="The FQAN suffix to append to the end of the Nagios service name.\n")
    parser.add_argument('--version', action='version', version=str(__version__))

    args = parser.parse_args()

    if args.hostname is None and args.uri is None:
        parser.error("neither --hostname nor --uri was given. " + helptext)

    if args.hostname is not None and args.path is None and args.uri is None:
        parser.error("no path specified. Using --path is mandatory with --hostname. " + helptext)

    # both --uri and --hostname were given.. make sure they match
    # Necessary because most nagios scripts are called with -H in
    # addition to all other arguments.
    if args.hostname is not None and args.uri is not None:
        uri = urlparse.urlparse(args.uri)
        if uri.hostname != args.hostname:
            parser.error("hostname in --uri does not match --hostname")

    if args.uri is None:
        args.uri = "https://{0}:{1}/{2}/".format(args.hostname, args.port, args.path)
    if not args.uri.endswith("/"):
        args.uri += "/"

    return args

def log(level, message, threshold=None):
    if level <= threshold:
        print(message, end="")

class SingleTest:
    def __init__(self, name, description, method, args, expected=None):
        self.name = name
        self.description = description
        self.method = method
        self.args = args
        self.expected = expected
    def run(self):
        return self.method(*self.args)

class TestResult(object):
    def __init__(self, status, elapsed, warning):
        self.status = status
        self.elapsed = elapsed
        self.failed = False
        self.unknown = False
        self.messages = []
        self.warning = warning
        self.header = None
        self.writeout = None
        self.debugout = None

    def validationFailure(self, msg):
        self.failed = True
        self.messages.append(msg)

    def unknownFailure(self, msg):
        self.unknown = True
        self.messages.append(msg)

    def setheader(self, header):
        self.header = header
    def setwriteout(self, writeout):
        self.writeout = writeout
    def setdebugout(self, debugout):
        self.debugout = debugout

    def diagnostic(self, msg):
        self.messages.append(msg)

    def finalize(self, name, description, expected_status=None):
        self.name = name
        self.description = description
        self.short_name = name.lower().replace(" ", "_").replace("-", "_")
        self.expected_status = expected_status
        self.outcome = self.determine_outcome()

    def determine_outcome(self):
        if self.unknown:
            return EX_UNKNOWN
        if self.failed:
            return EX_CRITICAL
        if self.expected_status != None and self.status != self.expected_status:
            return EX_CRITICAL
        elif (self.expected_status == None and (self.status < 200 or self.status >= 300)):
            return EX_CRITICAL
        elif self.elapsed >= self.warning:
            return EX_WARNING
        else:
            return EX_OK

    def short_output(self):
        if self.outcome == EX_CRITICAL or self.outcome == EX_UNKNOWN:
            return ""
        return "{0}={1:.2f}s".format(self.short_name, self.elapsed)

    def passive_short(self):
        s = code_to_str(self.outcome)
        out = "{0}: {1}".format(s, self.description)
        if self.outcome == EX_CRITICAL:
            out += " - {0}".format(http_status_to_explanation(self.status))
        return out

    def passive_long(self):
        l = self.long_output()
        if (self.outcome == EX_CRITICAL or self.outcome == EX_UNKNOWN) and self.debugout:
            return l + self.debugout
        return l

    def long_output(self):
        output = StringIO.StringIO()
        s = code_to_str(self.outcome)

        output.write("{0:20} {1:5} ({2:<10} sec)   {3}".format(self.name, self.status, self.elapsed, s))
        output.write("\n")
        for i in self.messages:
            output.write(i)
            output.write("\n")

        return output.getvalue()

class Tester(object):
    def __init__(self, args, logger):
        self.args = args
        # self.path = "https://{0}:{1}/{2}/".format(args.hostname, args.port, args.path)
        self.path = args.uri
        self.logger = logger

    def determine_exit_code(self, results):
        outcomes = [x.outcome for x in results]
        if outcomes.count(EX_CRITICAL) > 0:
            return EX_CRITICAL
        if outcomes.count(EX_WARNING) > 0:
            return EX_WARNING
        return EX_OK

    def publish_results(self, results):
        publish = []
        for r in results:
            item = {}
            item["status"] = r.outcome
            item["host"] = self.args.hostname
            item["details"] = r.passive_long()
            item["summary"] = r.passive_short()
            item["service"] = self.args.metric + "-" + r.short_name.upper() + "-" + self.args.fqan
            publish.append(item)

        self.logger(V_DEBUG, str(publish) + "\n")

        try:
            import gridmon.nagios.nagios
            gridmon.nagios.nagios.publishPassiveResult(publish)
        except Exception, e:
            self.logger(V_DEBUG, "Error: could not publish passive result, an exception occured\n")
            self.logger(V_DEBUG, "Exception text:  " + str(e) + "\n")

    def test(self):
        results = []

        target1 = self.path + __TEST_FILENAME__ + str(random.randint(0, __MAX_RND__))
        target2 = target1 + "_moved"

        # initial PUT request - if this fails, we're doomed
        results.append(self.put(target1))
        results[-1].finalize("PUT", "PUT a file")
        putfailed = results[-1].outcome != EX_OK

        alltests = [
            SingleTest("GET", "GET a file", self.get, [target1]),
            SingleTest("OPTIONS", "OPTIONS on file", self.options, [target1]),
            SingleTest("PUT on same path", "PUT on existing path, should return 409", self.put, [target1], expected=409),
            SingleTest("MOVE", "MOVE file to another path", self.move, [target1, target2]),
            SingleTest("HEAD", "HEAD on a file", self.head, [target2]),
            SingleTest("HEAD on non-existent", "HEAD on a file that does not exist, should return 404", self.head, [target1], expected=404),
            SingleTest("PROPFIND", "PROPFIND a file", self.propfind, [target2]),
            SingleTest("DELETE", "DELETE a file", self.delete, [target2])
        ]

        # run the rest of the tests
        for t in alltests:
            if putfailed:
                results.append(TestResult(0, 0, 0))
                results[-1].unknownFailure("PUT failed - bailing out")
            else:
                results.append(t.run())
            results[-1].finalize(t.name, t.description, t.expected)

        # print all output
        global_outcome = self.determine_exit_code(results)
        if global_outcome == EX_OK:
            self.logger(V_MINIMAL, "OK: all tests successful")
        elif global_outcome == EX_WARNING:
            self.logger(V_MINIMAL, "WARNING: some tests slow")
        elif global_outcome == EX_CRITICAL:
            self.logger(V_MINIMAL, "CRITICAL: some tests failed")
        elif global_outcome == EX_UNKNOWN:
            self.logger(V_MINIMAL, "UNKNOWN: an unknown error occured")

        self.logger(V_EXTENDED, " | ")
        for result in results:
            self.logger(V_EXTENDED, result.short_output())
            self.logger(V_EXTENDED, ";; ")
        self.logger(V_DEBUG, "\n")
        self.logger(V_DEBUG, "URI " + str(target1) + "\n")

        for result in results:
            self.logger(V_DEBUG, result.long_output())

        self.logger(V_MINIMAL, "\n")
        if self.args.metric:
            self.publish_results(results)

        return global_outcome

class CurlTester(Tester):
    def __init__(self, args, logger):
        Tester.__init__(self, args, logger)
        self.insecure = False
    def getcurl(self, target):
        args = self.args
        curl = pycurl.Curl()
        curl.setopt(pycurl.CONNECTTIMEOUT, args.timeout)
        curl.setopt(pycurl.TIMEOUT, args.timeout)
        curl.setopt(pycurl.SSL_VERIFYPEER, 1)
        curl.setopt(pycurl.SSL_VERIFYHOST, 2)
        curl.setopt(pycurl.FOLLOWLOCATION, 1)

        curl.setopt(pycurl.CAINFO, args.proxy)
        curl.setopt(pycurl.SSLCERT, args.proxy)
        curl.setopt(pycurl.CAPATH, args.capath)
        curl.setopt(pycurl.URL, target)
        curl.setopt(pycurl.SSL_VERIFYPEER, not self.insecure)

        self.curlout = StringIO.StringIO()
        curl.setopt(pycurl.WRITEFUNCTION, self.curlout.write)

        self.curlhdr = StringIO.StringIO()
        curl.setopt(pycurl.HEADERFUNCTION, self.curlhdr.write)

        self.curldebug = StringIO.StringIO()
        curl.setopt(curl.VERBOSE, 1)
        curl.setopt(pycurl.DEBUGFUNCTION, lambda x, y: self.curldebug.write(str(x) + y))

        return curl
    def put(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.POSTFIELDS, __TEST_FILE__)
        curl.setopt(pycurl.CUSTOMREQUEST, "PUT")
        return self.perform(curl)
    def delete(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.CUSTOMREQUEST, "DELETE")
        return self.perform(curl)
    def options(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.CUSTOMREQUEST, "OPTIONS")
        result = self.perform(curl)

        allows = None
        for line in self.curlhdr.getvalue().split("\n"):
            if line.startswith("Allow:"):
                allows = line

        if allows is None:
            result.validationFailure("ERROR: Could not find Allow response")
        else:
            result.diagnostic(allows)

        return result
    def move(self, source, destination):
        curl = self.getcurl(source)
        curl.setopt(pycurl.CUSTOMREQUEST, "MOVE")
        curl.setopt(pycurl.HTTPHEADER, ["Destination: {0}".format(destination)])
        return self.perform(curl)
    def head(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.NOBODY, 1)
        return self.perform(curl)
    def propfind(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.CUSTOMREQUEST, "PROPFIND")
        return self.perform(curl)
    def get(self, target):
        curl = self.getcurl(target)
        result = self.perform(curl)
        if self.curlout.getvalue() != __TEST_FILE__:
            result.validationFailure("ERROR: The file downloaded not the same as the file uploaded!")
        return result
    def perform(self, curl):
        try:
            curl.perform()

            status = curl.getinfo(pycurl.HTTP_CODE)
            elapsed = curl.getinfo(pycurl.TOTAL_TIME)
            result = TestResult(status, elapsed, self.args.warning)

            result.setheader(self.curlhdr.getvalue())
            result.setwriteout(self.curlout.getvalue())

            if self.args.verbose >= V_ALL:
                result.setdebugout(self.curldebug.getvalue())
            return result
        except Exception, e:
            result = TestResult(0, 0, self.args.warning)
            result.validationFailure("Curl exception: " + str(e))
            return result

# might remain unused
def filterhost(h):
    if "://" in h:
        h = h[h.find("://")+3:]
    if "/" in h:
        h = h[:h.find("/")]
    if ":" in h:
        self.port = h[h.find(":")+1:]
        h = h[:h.find(":")]

def main():
    try:
        args = getargs()
        logger = functools.partial(log, threshold=args.verbose)
        tester = CurlTester(args, logger)
        return tester.test()
    except Exception, e:
        print("An unknown error occured")
        print(traceback.format_exc())
        return EX_UNKNOWN
if __name__ == "__main__":
    sys.exit(main())
