#!/usr/bin/env python
##############################################################################
# Copyright (c) Members of the EGEE Collaboration. 2011.
# See http://www.eu-egee.org/partners/ for details on the copyright
# holders.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS
# OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##############################################################################
#
# NAME :        check_webdav_endpoint
#
# DESCRIPTION : Checks the webdav interface to an endpoint
#
# AUTHORS :     Georgios Bitzes <georgios.bitzes@cern.ch>
#
##############################################################################

from __future__ import print_function, division, absolute_import

import os
import sys
import time
import pycurl
import functools
import argparse
import StringIO
import random
import traceback
import urlparse
import cgi
import subprocess
import re

__version__ = "0.3.0"

__MAX_RND__ = 99
__TEST_FILENAME__ = "test_webdav_access_"
__TEST_FILE__ = "This is a test file generated by the nagios probe check-webdav from package nagios-plugins-webdav. It is safe to delete.\n"


# Verbosity
V_MINIMAL  = 0
V_EXTENDED = 1
V_DEBUG    = 2
V_ALL      = 3

EX_OK              = 0
EX_WARNING         = 1
EX_CRITICAL        = 2
EX_UNKNOWN         = 3

def code_to_str(code):
    if code == EX_CRITICAL:
        return "FAILURE"
    elif code == EX_WARNING:
        return "WARNING"
    elif code == EX_OK:
        return "OK"
    elif code == EX_UNKNOWN:
        return "UNKNOWN"

def ensure_safe_path(path):
    # Before running a dangerous operation (ie delete), make sure the path contains __TEST_FILENAME__
    # If not, something terribly wrong is going on. This should never trigger under any circumstances.

    if path.count(__TEST_FILENAME__) <= 0:
        raise Exception("ERROR: Refusing to touch something which does not contain {0}".format(__TEST_FILENAME__))

    if path.endswith("/"):
        raise Exception("ERROR: Refusing to touch a directory")

def http_status_to_explanation(status):
    if status == 404:
        return "404 file/path not found (are you using an incorrect path?)"
    elif status == 403:
        return "403 forbidden (are you using a valid certificate and path?)"
    elif status == 401:
        return "401 unauthorized (are you using a valid certificate and path?)"
    elif status == 500:
        return "500 server error"
    elif status == 507:
        return "507 insufficient storage"
    elif status == 0:
        return "connection failure (service down? SSL not configured properly?)"
    return "status {0}".format(status)

def add_prefix(string, prefix):
    """Returns a new string with the prefix string added before each line"""
    ss = StringIO.StringIO()
    for line in string.splitlines():
        ss.write(prefix + line + "\n")
    return ss.getvalue()

def get_vo(proxy):
    """Returns the VO of the provided proxy"""
    process = subprocess.Popen(["voms-proxy-info", "-file", proxy, "-vo"],
                               stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    return stdout.strip()

credentials = ""
def get_credentials_information(proxy):
    """Returns verbose information about the given proxy"""
    process = subprocess.Popen(["voms-proxy-info", "-file", proxy, "-all"],
                               stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    return stdout

def getargs():
    class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter, argparse.RawTextHelpFormatter):
        pass

    helptext = "Use either --uri or (--hostname, --port, and --path) to specify the target."

    parser = argparse.ArgumentParser(formatter_class=CustomFormatter,
                                     description="Checks the WebDAV capabilities of an endpoint.\n" + helptext,
                                     epilog="The script will return the following exit code:\n"
                                     "\t{0}, if all tests passed\n".format(EX_OK) +
                                     "\t{0}, if all tests passed but some were over the warning threshold\n".format(EX_WARNING) +
                                     "\t{0}, if some tests failed\n".format(EX_CRITICAL) +
                                     "\t{0}, if status is unknown\n".format(EX_UNKNOWN))

    # group = parser.add_mutually_exclusive_group(required=True)
    parser.add_argument('-H', '--hostname', type=str, help="The hostname to query\n")
    parser.add_argument('-u', '--uri', type=str, help="The target URI to test")

    parser.add_argument('-E', '--proxy', type=str, required=True, help="The path to the proxy certificate to use\n")
    parser.add_argument('-p', '--port', type=int, default=443, help="The server port to use\n")
    parser.add_argument('-P', '--path', type=str, help="The target server path to test\n")
    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help="Verbosity levels:\n"
                        " -v   -> display some information about every test\n"
                        " -vv  -> show detailed information about every test\n"
                        " -vvv -> print server responses and headers, only for debugging\n")
    parser.add_argument('--capath', type=str, default="/etc/grid-security/certificates",
                        help="The certificate store to verify host credentials\n")
    parser.add_argument('-w', '--warning', type=int, default=10, help="Sets the warning threshold (seconds)\n")
    parser.add_argument('-t', '--timeout', type=int, default=30, help="Sets the timeout threshold (seconds)\n")
    parser.add_argument('-m', '--metric', type=str, help="The metric prefix under which to publish the results in Nagios.\n"
                        "Results will not be published if it isn't specified.")
    parser.add_argument('-f', '--fqan', type=str, default="", help="The FQAN suffix to append to the end of the Nagios service name.\n")
    parser.add_argument('--version', action='version', version=str(__version__))

    parser.add_argument('-c', '--no-crls', action='store_true', help="Copies the capath to a temporary location (given by --tempcapath),"
                        " while excluding Certificate Revocation Lists (all *.r0 files). "
                        "Necessary because of a bug in NSS that sometimes results in 'curl: (35) SSL connect error'")
    parser.add_argument('--tempcapath', type=str, default="/tmp/check-webdav_tempcapath",
                        help="The location to which the capath should be copied to. Only applies in case --no-crls is given.")

    args = parser.parse_args()

    if args.hostname is None and args.uri is None:
        parser.error("neither --hostname nor --uri was given. " + helptext)

    if args.hostname is not None and args.path is None and args.uri is None:
        parser.error("no path specified. Using --path is mandatory with --hostname. " + helptext)

    # both --uri and --hostname were given.. make sure they match
    # Necessary because most nagios scripts are called with -H in
    # addition to all other arguments.
    if args.hostname is not None and args.uri is not None:
        uri = urlparse.urlparse(args.uri)
        if uri.hostname != args.hostname:
            parser.error("hostname in --uri does not match --hostname")

    if args.uri is None:
        args.uri = "https://{0}:{1}/{2}/".format(args.hostname, args.port, args.path)
    if not args.uri.endswith("/"):
        args.uri += "/"

    return args

def log(level, message, threshold=None):
    if level <= threshold:
        print(message, end="")

class SingleTest:
    """A class to help run a single test and produce the corresponding TestResult"""
    def __init__(self, name, description, method, args, expected=range(200, 300), critical=True):
        self.name = name
        self.description = description
        self.method = method
        self.args = args
        self.expected = expected
        self.critical = critical
    def finalize(self, result):
        result.setparams(self.name, self.description, expected_status=self.expected, critical=self.critical)
        result.finalize()
    def run(self):
        result = self.method(*self.args)
        self.finalize(result)
        return result
    def skip(self, msg):
        result = TestResult(0)
        result.diagnostic(msg)
        self.finalize(result)
        return result

class TestResult(object):
    """A class to store and display the results from a single test run"""
    STATE_NOT_RUN = 1
    STATE_RUN     = 2
    STATE_FAILED  = 3

    def __init__(self, warnthres):
        self.state = TestResult.STATE_NOT_RUN
        self.warnthres = warnthres

        self.messages = []
        self.history = None
        self.target = None

        self.status = 0
        self.elapsed = 0
    def set(self, status, elapsed):
        self.status = status
        self.elapsed = elapsed
        if self.state == TestResult.STATE_NOT_RUN:
            self.state = TestResult.STATE_RUN

    def failure(self, msg):
        self.diagnostic(msg)
        self.state = TestResult.STATE_FAILED

    def sethistory(self, history):
        self.history = history

    def diagnostic(self, msg):
        self.messages.append(msg)

    def setparams(self, name, description, expected_status, critical):
        self.name = name
        self.description = description
        self.short_name = name.lower().replace(" ", "_").replace("-", "_")
        self.expected_status = expected_status
        self.critical = critical

    def finalize(self):
        if self.state != TestResult.STATE_NOT_RUN and self.elapsed >= self.warnthres:
            self.diagnostic("Test is slow - took more than {0} seconds".format(self.warnthres))

        self.outcome = self.determine_outcome()

    def determine_outcome(self):
        FAILURE = EX_CRITICAL
        if not self.critical:
            FAILURE = EX_WARNING

        if self.state == TestResult.STATE_NOT_RUN:
            return EX_UNKNOWN
        if self.state == TestResult.STATE_FAILED:
            return FAILURE

        assert self.state == TestResult.STATE_RUN
        if self.status not in self.expected_status:
            return FAILURE
        elif self.elapsed >= self.warnthres:
            return EX_WARNING
        else:
            return EX_OK

    def performance_data(self):
        # If a test fails, make nagios show an empty graph
        if self.outcome == EX_CRITICAL or self.outcome == EX_UNKNOWN or self.status not in self.expected_status:
            return ""
        return "{0}={1:.2f}s".format(self.short_name, self.elapsed)

    def short_output(self):
        s = code_to_str(self.outcome)
        out = "{0}: {1}".format(s, self.description)
        if self.outcome == EX_CRITICAL:
            out += " - {0}".format(http_status_to_explanation(self.status))
        return out

    def long_output(self, printHTML=False):
        if printHTML:
            indent = "&nbsp;"*4
        else:
            indent = " "*4

        output = StringIO.StringIO()
        s = code_to_str(self.outcome)

        output.write("{0:29} {1:5} ({2:<10} sec)   {3}\n".format(self.name, self.status, self.elapsed, s))

        if self.target:
            output.write(add_prefix("Target: " + self.target + "\n", indent))

        for i in self.messages:
            output.write(add_prefix(i,indent))

        if self.outcome == EX_CRITICAL or self.outcome == EX_WARNING:
            output.write(add_prefix("For guidance on troubleshooting a failing endpoint, please have a look at https://twiki.cern.ch/twiki/bin/view/LCG/HTTPTFSAMProbe", indent))
            output.write(add_prefix("Credentials:\n", indent))
            output.write(add_prefix(credentials, indent*2))

        if (self.outcome != EX_OK) and self.history:
            output.write(add_prefix("Server response: {0}\n".format(http_status_to_explanation(self.status)), indent))
            output.write(add_prefix("Debugging information: the history of all performed requests and "
                                    "received responses during the execution of this test follows.\n", indent))
            if printHTML:
                output.write(add_prefix(cgi.escape(self.history), indent))
            else:
                output.write(add_prefix(self.history, indent))

        return output.getvalue()

class Tester(object):
    def __init__(self, args):
        self.args = args
        self.path = args.uri

    def log(self, level, message):
        if level <= self.args.verbose:
            print(message, end="")

    def determine_exit_code(self, results):
        outcomes = [x.outcome for x in results if x.critical]

        if outcomes.count(EX_CRITICAL) > 0:
            return EX_CRITICAL
        if outcomes.count(EX_WARNING) > 0:
            return EX_WARNING
        return EX_OK

    def print_results(self, results):
        """Print all necessary output to stdout"""
        if self.global_outcome == EX_OK:
            self.log(V_MINIMAL, "OK: the HTTP interface is usable")
        elif self.global_outcome == EX_WARNING:
            self.log(V_MINIMAL, "WARNING: one or more tests have issues")
        elif self.global_outcome == EX_CRITICAL:
            self.log(V_MINIMAL, "CRITICAL: one or more tests failed")
        elif self.global_outcome == EX_UNKNOWN:
            self.log(V_MINIMAL, "UNKNOWN: an unknown error occured")

        # publish performance data, used by nagios in making graphs
        self.log(V_EXTENDED, " | ")
        for result in results:
            self.log(V_EXTENDED, result.performance_data())
            self.log(V_EXTENDED, "  ")
        self.log(V_DEBUG, "\n")

        # if running inside nagios, escape all HTML
        printHTML = "NAGIOS_ARG1" in os.environ

        for result in results:
            longout = result.long_output(printHTML=printHTML)
            # prevent nagios from going insane if there's a pipe in the HTML page output
            if printHTML: longout = longout.replace("|", "--pipe symbol--")
            self.log(V_DEBUG, longout)

        self.log(V_MINIMAL, "\n")

    def publish_results(self, results):
        """Publish the passive test results to Nagios."""
        publish = []
        for r in results:
            item = {}
            item["status"] = r.outcome

            # mark a failed PUT as WARNING, not CRITICAL
            if r.name == "FILE PUT" and r.outcome == EX_CRITICAL:
                item["status"] = EX_WARNING

            item["host"] = urlparse.urlparse(self.args.uri).hostname
            item["details"] = r.long_output(printHTML=True)
            item["summary"] = r.short_output()
            item["service"] = self.args.metric + "-" + r.short_name.upper() + "-" + self.args.fqan
            publish.append(item)

        try:
            import gridmon.nagios.nagios
            gridmon.nagios.nagios.publishPassiveResult(publish)
        except Exception, e:
            self.log(V_DEBUG, "Error: could not publish passive result, an exception occured\n")
            self.log(V_DEBUG, "Exception text:  " + str(e) + "\n")

    def run_put_ok_tests(self, target1, target2):
        """Run all 'put-succeeded' tests and return the results"""
        results = []
        tests = [
            SingleTest("FILE GET", "GET file", self.get, [target1, __TEST_FILE__]),
            SingleTest("FILE OPTIONS", "OPTIONS on file", self.options, [target1]),
            SingleTest("FILE MOVE", "MOVE file to another path", self.move, [target1, target2]),
            SingleTest("FILE HEAD", "HEAD on file", self.head, [target2]),
            SingleTest("FILE HEAD on non-existent", "HEAD on a path that does not exist, should return 404",
                       self.head, [target1], expected=[404]),
            SingleTest("FILE PROPFIND", "PROPFIND on file", self.propfind, [target2]),
            SingleTest("FILE DELETE", "DELETE on file", self.delete, [target2]),
            SingleTest("FILE DELETE on non-existent", "DELETE on a file that does not exist, should return 404",
                       self.delete, [target1], expected=[404], critical=False)
        ]

        for t in tests: results.append(t.run())
        return results

    def run_put_failed_tests(self):
        """Run all 'put-failed' tests and return the results"""
        results = []

        # check if the standard file exists
        standard_file = self.path + "{0}_HTTPTFtest.txt".format(get_vo(self.args.proxy).upper())
        get = SingleTest("FILE GET", "GET file", self.get, [standard_file])
        results.append(get.run())
        getfailed = results[-1].outcome == EX_CRITICAL or results[-1].outcome == EX_UNKNOWN

        readtests = [
            SingleTest("FILE OPTIONS", "OPTIONS on file", self.options, [standard_file]),
            SingleTest("FILE HEAD", "HEAD on file", self.head, [standard_file]),
            SingleTest("FILE HEAD on non-existent", "HEAD on a path that does not exist, should return 404",
                       self.head,[standard_file+"does_not_exist"], expected=[404]),
            SingleTest("FILE PROPFIND", "PROPFIND on file", self.propfind, [standard_file]),
        ]

        for t in readtests:
            if not getfailed:
                results.append(t.run())
            else:
                results.append(t.skip("Standard file not found, skipping"))

        skipped = [
            SingleTest("FILE MOVE", "MOVE file to another path", None, None),
            SingleTest("FILE DELETE", "DELETE on file", None, None),
            SingleTest("FILE DELETE on non-existent", "DELETE on a file that does not exist, should return 404",
                        None, None)
        ]

        for t in skipped: results.append(t.skip("PUT failed, skipping"))
        return results

    def test(self):
        results = []

        target1 = self.path + __TEST_FILENAME__ + str(random.randint(0, __MAX_RND__))
        target2 = target1 + "_moved"

        # declare read tests
        readtests = [
            SingleTest("DIR HEAD", "HEAD on dir", self.head, [self.path]),
            SingleTest("DIR GET", "GET on dir", self.get, [self.path, None])
        ]

        # run read tests
        for t in readtests:
            results.append(t.run())

        # initial PUT - do I have write access to the server?
        put = SingleTest("FILE PUT", "PUT a file", self.put, [target1], critical=False)
        results.append(put.run())
        putok = results[-1].status >= 200 and results[-1].status < 300

        if putok:
            results += self.run_put_ok_tests(target1, target2)
        else:
            results += self.run_put_failed_tests()

        # print all output
        self.global_outcome = self.determine_exit_code(results)
        self.print_results(results)

        # do a cleanup, remove any files that might have been left over from a previous failed run
        self.cleanup(self.path)

        # publish results to nagios
        if self.args.metric:
            self.publish_results(results)

        return self.global_outcome

class CurlTester(Tester):
    def __init__(self, args):
        Tester.__init__(self, args)
        self.insecure = False
    def getcurl(self, target):
        args = self.args
        curl = pycurl.Curl()
        curl.setopt(pycurl.CONNECTTIMEOUT, args.timeout)
        curl.setopt(pycurl.TIMEOUT, args.timeout)
        curl.setopt(pycurl.SSL_VERIFYPEER, 1)
        curl.setopt(pycurl.SSL_VERIFYHOST, 2)
        curl.setopt(pycurl.SSLVERSION, pycurl.SSLVERSION_TLSv1)

        curl.setopt(pycurl.FOLLOWLOCATION, 1)

        curl.setopt(pycurl.CAINFO, args.proxy)
        curl.setopt(pycurl.SSLCERT, args.proxy)
        curl.setopt(pycurl.CAPATH, args.capath)
        curl.__mytarget  = target # pycurl does not support getting the URL back, so let's improvise
        curl.setopt(pycurl.URL, target)
        curl.setopt(pycurl.SSL_VERIFYPEER, not self.insecure)

        self.responseBody = StringIO.StringIO()
        curl.setopt(pycurl.WRITEFUNCTION, self.responseBody.write)

        self.responseHeader = StringIO.StringIO()
        curl.setopt(pycurl.HEADERFUNCTION, self.responseHeader.write)

        self.history = StringIO.StringIO()
        def debugfunction(self, msgtype, msg):
            # request
            if msgtype == 2 or msgtype == 4:
                self.history.write(add_prefix(msg, "=> "))
            # response
            if msgtype == 1 or msgtype == 3:
                self.history.write(add_prefix(msg, "<= "))

        curl.setopt(curl.VERBOSE, 1)
        curl.setopt(pycurl.DEBUGFUNCTION, lambda x, y: debugfunction(self, x, y))

        return curl
    def put(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.POSTFIELDS, __TEST_FILE__)
        curl.setopt(pycurl.CUSTOMREQUEST, "PUT")
        return self.perform(curl)
    def delete(self, target):
        # safety check: make sure we aren't deleting anything important
        ensure_safe_path(target)

        curl = self.getcurl(target)
        curl.setopt(pycurl.CUSTOMREQUEST, "DELETE")
        return self.perform(curl)
    def options(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.CUSTOMREQUEST, "OPTIONS")
        result = self.perform(curl)

        allows = None
        for line in self.responseHeader.getvalue().split("\n"):
            if line.startswith("Allow:"):
                allows = line

        if allows is None:
            result.failure("ERROR: Could not find Allow response")
        else:
            result.diagnostic(allows)

        return result
    def move(self, source, destination):
        ensure_safe_path(source)
        ensure_safe_path(destination)

        curl = self.getcurl(source)
        curl.setopt(pycurl.CUSTOMREQUEST, "MOVE")
        curl.setopt(pycurl.HTTPHEADER, ["Destination: {0}".format(destination)])
        return self.perform(curl)
    def head(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.NOBODY, 1)
        return self.perform(curl)
    def propfind(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.CUSTOMREQUEST, "PROPFIND")
        curl.setopt(pycurl.HTTPHEADER, ["Depth: 1"])
        curl.setopt(pycurl.POSTFIELDS, '<?xml version="1.0"?><a:propfind xmlns:a="DAV:"><a:prop></a:prop></a:propfind>')
        return self.perform(curl)
    def get(self, target, contents=None):
        curl = self.getcurl(target)
        result = self.perform(curl)
        if contents is not None and self.responseBody.getvalue() != contents:
            result.failure("ERROR: File contents are wrong!")
        return result
    # clean all residual testfiles in target directory that might have been
    # left by previous runs of this script.
    # Prevents accumulation of testfiles
    def cleanup(self, target):
        print("Looking for left-over testfiles from previous failed runs..")
        self.propfind(target)
        xml = self.responseBody.getvalue()
        uri = urlparse.urlparse(target)

        iter = re.finditer(re.escape("<") + "[Dd]" + re.escape(":href>")
               + "(" + re.escape(uri.path) + __TEST_FILENAME__ + "\d+(_moved)?" + ")"
               + re.escape("</") + "[Dd]" + re.escape(":href>"), xml)
        for match in iter:
            path = match.group(1)
            newuri = uri._replace(path=path)
            print("Cleanup - deleting left-over testfile: " + newuri.geturl())
            self.delete(newuri.geturl())

        print("All done")
    def perform(self, curl):
        """Return a TestResult object with information about what happened during the request"""
        result = TestResult(self.args.warning)
        try:
            curl.perform()

            status = curl.getinfo(pycurl.HTTP_CODE)
            elapsed = curl.getinfo(pycurl.TOTAL_TIME)
            result.set(status, elapsed)
        except Exception, e:
            result.failure("Curl exception: " + str(e))

        result.sethistory(self.history.getvalue())
        result.target = curl.__mytarget
        return result

def prepare_custom_capath(capath, tempcapath):
    DEVNULL = open(os.devnull, 'wb')
    process = subprocess.Popen(["rsync", "--archive", "--exclude", "*.r0", capath + "/", tempcapath],
                               stdout=DEVNULL, stderr=subprocess.STDOUT)
    ret = process.wait()
    # assert ret == 0

def main():
    try:
        args = getargs()

        if args.no_crls:
            prepare_custom_capath(args.capath, args.tempcapath)
            args.capath = args.tempcapath

        global credentials
        credentials = get_credentials_information(args.proxy)

        tester = CurlTester(args)
        return tester.test()
    except Exception, e:
        print("An unknown error occured")
        print(traceback.format_exc())
        return EX_UNKNOWN
if __name__ == "__main__":
    sys.exit(main())
