#!/usr/bin/env python
##############################################################################
# Copyright (c) Members of the EGEE Collaboration. 2011.
# See http://www.eu-egee.org/partners/ for details on the copyright
# holders.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS
# OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##############################################################################
#
# NAME :        check_webdav_endpoint
#
# DESCRIPTION : Checks the webdav interface to an endpoint
#
# AUTHORS :     Ivan Calvet <ivan.calvet@cern.ch>
#               Georgios Bitzes <georgios.bitzes@cern.ch>
#
##############################################################################

from __future__ import print_function, division, absolute_import

import os
import sys
import time
import pycurl
import ldap
import functools
import argparse
import StringIO
import random

__version__ = "0.1"

__MAX_RND__ = 999999999
__TEST_FILENAME__ = "test_webdav_access_"
__TEST_FILE__ = "This is a test file generated by the nagios probe nagios-plugins-webdav. It is safe to delete.\n"

# Verbosity
V_MINIMAL  = 0
V_EXTENDED = 1
V_DEBUG    = 2
V_ALL      = 3

EX_OK       = 0
EX_WARNING  = 1
EX_CRITICAL = 2
EX_UNKNOWN  = 3

def getargs():
    class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter, argparse.RawTextHelpFormatter):
        pass

    parser = argparse.ArgumentParser(formatter_class=CustomFormatter,
                                     description="Checks the WebDAV capabilities of an endpoint",
                                     epilog="The script will return the following exit code:\n"
                                     "\t{0}, if all tests passed\n".format(EX_OK) +
                                     "\t{0}, if all tests passed but some were over the warning threshold\n".format(EX_WARNING) +
                                     "\t{0}, if some tests failed\n".format(EX_CRITICAL) +
                                     "\t{0}, if status is unknown\n".format(EX_UNKNOWN))

    parser.add_argument('-E', '--proxy', type=str, required=True, help="The path to the proxy certificate to use\n")

    parser.add_argument('-H', '--hostname', type=str, required=True, help="The hostname to query\n")
    parser.add_argument('-p', '--port', type=int, default=443, help="The server port to use\n")
    parser.add_argument('-P', '--path', type=str, required=True, help="The target server path to test\n")
    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help="Verbosity levels:\n"
                        " -v   -> display some information about every test\n"
                        " -vv  -> show detailed information about every test\n"
                        " -vvv -> print server responses and headers, only for debugging\n")
    parser.add_argument('--capath', type=str, default="/etc/grid-security/certificates",
                        help="The certificate store to verify host credentials\n")
    parser.add_argument('-w', '--warning', type=int, default=4, help="Sets the warning threshold (seconds)\n")
    parser.add_argument('-t', '--timeout', type=int, default=10, help="Sets the timeout threshold (seconds)\n")

    return parser.parse_args()

def log(level, message, threshold=None):
    if level <= threshold:
        print(message, end="")

class TestResult(object):
    def __init__(self, status, elapsed, warning):
        self.status = status
        self.elapsed = elapsed
        self.failed = False
        self.messages = []
        self.warning = warning

    def validationFailure(self, msg):
        self.failed = True
        self.messages.append(msg)

    def diagnostic(self, msg):
        self.messages.append(msg)

    def finalize(self, name, expected_status=None):
        self.name = name
        self.short_name = name.lower().replace(" ", "_").replace("-", "_")
        self.expected_status = expected_status
        self.outcome = self.determine_outcome()

    def determine_outcome(self):
        if self.failed:
            return EX_CRITICAL
        if self.expected_status != None and self.status != self.expected_status:
            return EX_CRITICAL
        elif (self.expected_status == None and (self.status < 200 or self.status >= 300)):
            return EX_CRITICAL
        elif self.elapsed >= self.warning:
            return EX_WARNING
        else:
            return EX_OK

    def short_output(self):
        if self.outcome == EX_CRITICAL:
            return "{0}=fail".format(self.short_name)
        return "{0}={1:.2f}".format(self.short_name, self.elapsed)

    def long_output(self):
        output = StringIO.StringIO()
        if self.outcome == EX_CRITICAL:
            s = "FAILURE"
        elif self.outcome == EX_WARNING:
            s = "SLOW"
        elif self.outcome == EX_OK:
            s = "SUCCESS"
        elif self.outcome == EX_UNKNOWN:
            s = "UNKNOWN"

        output.write("{0:20} {1:5} ({2:<10} sec)   {3}".format(self.name, self.status, self.elapsed, s))
        output.write("\n")
        for i in self.messages:
            output.write(i)
            output.write("\n")

        return output.getvalue()

class Tester(object):
    def __init__(self, args, logger):
        self.args = args
        self.path = "https://{0}:{1}/{2}/".format(args.hostname, args.port, args.path)
        self.logger = logger

    def determine_exit_code(self, results):
        outcomes = [x.outcome for x in results]
        size = len(outcomes)
        if outcomes.count(EX_CRITICAL) > 0:
            return EX_CRITICAL
        if outcomes.count(EX_WARNING) > 0:
            return EX_WARNING
        return EX_OK

    def test(self):
        results = []

        # PUT
        target = self.path + __TEST_FILENAME__ + str(random.randint(0, __MAX_RND__))
        results.append(self.put(target))
        results[-1].finalize("PUT")

        # GET
        results.append(self.get(target))
        results[-1].finalize("GET")

        # OPTIONS
        results.append(self.options(target))
        results[-1].finalize("OPTIONS")

        # PUT file again, expecting this to fail
        results.append(self.put(target))
        results[-1].finalize("PUT on same path", 409)

        # MOVE
        source = target
        target = target + "_moved"
        results.append(self.move(source, target))
        results[-1].finalize("MOVE")

        # HEAD
        results.append(self.head(target))
        results[-1].finalize("HEAD")

        # HEAD on moved source, expecting to fail
        results.append(self.head(source))
        results[-1].finalize("HEAD on non-existent", 404)

        # PROPFIND
        results.append(self.propfind(target))
        results[-1].finalize("PROPFIND")

        # DELETE
        results.append(self.delete(target))
        results[-1].finalize("DELETE")

        global_outcome = self.determine_exit_code(results)
        if global_outcome == EX_OK:
            self.logger(V_MINIMAL, "OK: all tests successful")
        elif global_outcome == EX_WARNING:
            self.logger(V_MINIMAL, "WARNING: some tests slow")
        elif global_outcome == EX_CRITICAL:
            self.logger(V_MINIMAL, "CRITICAL: some tests failed")
        elif global_outcome == EX_UNKNOWN:
            self.logger(V_MINIMAL, "UNKNOWN: an unknown error occured")

        self.logger(V_EXTENDED, " | ")
        for result in results:
            self.logger(V_EXTENDED, result.short_output())
            self.logger(V_EXTENDED, " ")
        self.logger(V_DEBUG, "|\n")
        self.logger(V_DEBUG, "URI " + str(source) + "\n")

        for result in results:
            self.logger(V_DEBUG, result.long_output())

        self.logger(V_MINIMAL, "\n")

        return global_outcome

class CurlTester(Tester):
    def __init__(self, args, logger):
        Tester.__init__(self, args, logger)
    def getcurl(self, target):
        args = self.args
        curl = pycurl.Curl()
        curl.setopt(pycurl.CONNECTTIMEOUT, args.timeout)
        curl.setopt(pycurl.TIMEOUT, args.timeout)
        curl.setopt(pycurl.SSL_VERIFYPEER, 1)
        curl.setopt(pycurl.SSL_VERIFYHOST, 2)
        curl.setopt(pycurl.FOLLOWLOCATION, 1)

        curl.setopt(pycurl.CAINFO, args.proxy)
        curl.setopt(pycurl.SSLCERT, args.proxy)
        curl.setopt(pycurl.CAPATH, args.capath)
        curl.setopt(pycurl.URL, target)

        curl.setopt(pycurl.WRITEFUNCTION, lambda x: None)

        if self.args.verbose >= V_ALL:
            curl.setopt(curl.VERBOSE, 1)
            curl.setopt(pycurl.DEBUGFUNCTION, lambda x, y: self.logger(V_ALL, y))
        return curl
    def put(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.POSTFIELDS, __TEST_FILE__)
        curl.setopt(pycurl.CUSTOMREQUEST, "PUT")
        return self.perform(curl)
    def delete(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.CUSTOMREQUEST, "DELETE")
        return self.perform(curl)
    def options(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.CUSTOMREQUEST, "OPTIONS")
        buffer = StringIO.StringIO()
        curl.setopt(curl.HEADERFUNCTION, buffer.write)
        result = self.perform(curl)

        allows = None
        for line in buffer.getvalue().split("\n"):
            if line.startswith("Allow:"):
                allows = line

        if allows is None:
            result.validationFailure("ERROR: Could not find Allow response")
        else:
            result.diagnostic(allows)

        return result
    def move(self, source, destination):
        curl = self.getcurl(source)
        curl.setopt(pycurl.CUSTOMREQUEST, "MOVE")
        curl.setopt(pycurl.HTTPHEADER, ["Destination: {0}".format(destination)])
        return self.perform(curl)
    def head(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.NOBODY, 1)
        return self.perform(curl)
    def propfind(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.CUSTOMREQUEST, "PROPFIND")
        return self.perform(curl)
    def get(self, target):
        curl = self.getcurl(target)
        buffer = StringIO.StringIO()
        curl.setopt(curl.WRITEFUNCTION, buffer.write)

        result = self.perform(curl)
        if buffer.getvalue() != __TEST_FILE__:
            result.validationFailure("ERROR: The file downloaded not the same as the file uploaded!")
        return result
    def perform(self, curl):
        try:
            curl.perform()

            status = curl.getinfo(pycurl.HTTP_CODE)
            elapsed = curl.getinfo(pycurl.TOTAL_TIME)
            result = TestResult(status, elapsed, self.args.warning)
            return result
        except Exception, e:
            result = TestResult(0, 0, self.args.warning)
            result.validationFailure("Curl exception: " + str(e))
            return result

# might remain unused
def filterhost(h):
    if "://" in h:
        h = h[h.find("://")+3:]
    if "/" in h:
        h = h[:h.find("/")]
    if ":" in h:
        self.port = h[h.find(":")+1:]
        h = h[:h.find(":")]

def main():
    args = getargs()
    logger = functools.partial(log, threshold=args.verbose)
    tester = CurlTester(args, logger)
    return tester.test()

if __name__ == "__main__":
    sys.exit(main())
