#!/usr/bin/env python
##############################################################################
# Copyright (c) Members of the EGEE Collaboration. 2011.
# See http://www.eu-egee.org/partners/ for details on the copyright
# holders.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS
# OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##############################################################################
#
# NAME :        check_webdav_endpoint
#
# DESCRIPTION : Checks the webdav interface to an endpoint
#
# AUTHORS :     Ivan Calvet <ivan.calvet@cern.ch>
#               Georgios Bitzes <georgios.bitzes@cern.ch>
#
##############################################################################

from __future__ import print_function, division, absolute_import

import os
import sys
import time
import pycurl
import ldap
import functools
import argparse
import StringIO

__version__ = "0.1"

__TEST_FILENAME__ = "test_webdav_access.txt"
__TEST_FILE__ = "This is a test file generated by the nagios probe nagios-plugins-webdav. It is safe to delete.\n"

LOG_NOOUT = 0
LOG_INFO = 1
LOG_VERBOSE = 2

EXIT_OK = 0
EXIT_SOME_SLOW = 1
EXIT_SOME_FAIL = 2
EXIT_ALL_FAIL = 3

def getargs():
    class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter, argparse.RawTextHelpFormatter):
        pass

    parser = argparse.ArgumentParser(formatter_class=CustomFormatter,
                                     description="Checks the WebDAV capabilities of an endpoint",
                                     epilog="The script will return the following exit code:\n"
                                     "\t{0}, if all tests passed\n".format(EXIT_OK) +
                                     "\t{0}, if all tests passed but some were over the warning threshold\n".format(EXIT_SOME_SLOW) +
                                     "\t{0}, if only some tests passed\n".format(EXIT_SOME_FAIL) +
                                     "\t{0}, if all tests failed\n".format(EXIT_ALL_FAIL))

    parser.add_argument('-E', '--proxy', type=str, required=True, help="The path to the proxy certificate to use\n")

    parser.add_argument('-H', '--hostname', type=str, required=True, help="The hostname to query\n")
    parser.add_argument('-p', '--port', type=int, default=443, help="The server port to use\n")
    parser.add_argument('-P', '--path', type=str, required=True, help="The target server path to test\n")
    parser.add_argument('--verbosity', type=int, default=1, choices=range(0,3),
                        help="Verbosity levels:\n"
                        " {0} -> no output, only set an exit code\n".format(LOG_NOOUT) +
                        " {0} -> short overview of each request\n".format(LOG_INFO) +
                        " {0} -> verbose, print server responses\n".format(LOG_VERBOSE))
    parser.add_argument('--capath', type=str, default="/etc/grid-security/certificates",
                        help="The certificate store to verify host credentials\n")
    parser.add_argument('-w', '--warning', type=int, default=4, help="Sets the warning threshold (seconds)\n")
    parser.add_argument('-t', '--timeout', type=int, default=10, help="Sets the timeout threshold (seconds)\n")

    return parser.parse_args()

def log(level, message, threshold=None):
    if level <= threshold:
        print(message)

class TestResult(object):
    def __init__(self, status, elapsed):
        self.status = status
        self.elapsed = elapsed
        self.failed = False
        self.messages = []

    def validationFailure(self, msg):
        self.failed = True
        self.messages.append(msg)

    def diagnostic(self, msg):
        self.messages.append(msg)

    def determine_outcome(self, warning, expected_status):
        if self.failed:
            return "FAIL"
        if expected_status != None and self.status != expected_status:
            return "FAIL"
        elif (expected_status == None and (self.status < 200 or self.status >= 300)):
            return "FAIL"
        elif self.elapsed >= warning:
            return "SLOW"
        else:
            return "SUCCESS"

    def print_result(self, reqtype, logger, warning, expected_status=None):
        self.outcome = self.determine_outcome(warning, expected_status)
        logger(LOG_INFO, "{0:20} {1:5} ({2:<10} sec)   {3}".format(reqtype, self.status, self.elapsed, self.outcome))

        for i in self.messages: print(i)

class Tester(object):
    def __init__(self, args, logger):
        self.args = args
        self.path = "https://{0}:{1}/{2}/".format(args.hostname, args.port, args.path)
        self.logger = logger
        self.logger(LOG_INFO, "TARGET " + str(self.path))

    def determine_exit_code(self, results):
        outcomes = [x.outcome for x in results]
        size = len(outcomes)
        if outcomes.count("FAIL") == size:
            return EXIT_ALL_FAIL
        if outcomes.count("FAIL") > 0:
            return EXIT_SOME_FAIL
        if outcomes.count("SLOW") > 0:
            return EXIT_SOME_SLOW
        return EXIT_OK

    def test(self):
        results = []

        # PUT
        target = self.path + __TEST_FILENAME__
        results.append(self.put(target))
        results[-1].print_result("PUT", self.logger, self.args.warning)

        # GET
        results.append(self.get(target))
        results[-1].print_result("GET", self.logger, self.args.warning)

        # OPTIONS
        results.append(self.options(target))
        results[-1].print_result("OPTIONS", self.logger, self.args.warning)

        # PUT file again, expecting this to fail
        results.append(self.put(target))
        results[-1].print_result("PUT on same path", self.logger,
                                 self.args.warning, expected_status=409)
        # MOVE
        source = target
        target = target + "_moved"
        results.append(self.move(source, target))
        results[-1].print_result("MOVE", self.logger, self.args.warning)

        # HEAD
        results.append(self.head(target))
        results[-1].print_result("HEAD", self.logger, self.args.warning)

        # HEAD on moved source, expecting to fail
        results.append(self.head(source))
        results[-1].print_result("HEAD on non-existent", self.logger,
                                 self.args.warning, expected_status=404)

        # PROPFIND
        results.append(self.propfind(target))
        results[-1].print_result("PROPFIND", self.logger, self.args.warning)

        # DELETE
        results.append(self.delete(target))
        results[-1].print_result("DELETE", self.logger, self.args.warning)

        return self.determine_exit_code(results)

class CurlTester(Tester):
    def __init__(self, args, logger):
        Tester.__init__(self, args, logger)
    def getcurl(self, target):
        args = self.args
        curl = pycurl.Curl()
        curl.setopt(pycurl.CONNECTTIMEOUT, args.timeout)
        curl.setopt(pycurl.TIMEOUT, args.timeout)
        curl.setopt(pycurl.SSL_VERIFYPEER, 1)
        curl.setopt(pycurl.SSL_VERIFYHOST, 2)
        curl.setopt(pycurl.FOLLOWLOCATION, 1)

        curl.setopt(pycurl.CAINFO, args.proxy)
        curl.setopt(pycurl.SSLCERT, args.proxy)
        curl.setopt(pycurl.CAPATH, args.capath)
        curl.setopt(pycurl.URL, target)

        curl.setopt(pycurl.WRITEFUNCTION, lambda x: None)

        if self.args.verbosity >= LOG_VERBOSE:
            curl.setopt(curl.VERBOSE, 1)
            curl.setopt(pycurl.DEBUGFUNCTION, lambda x, y: self.logger(LOG_VERBOSE, y))
        return curl
    def put(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.POSTFIELDS, __TEST_FILE__)
        curl.setopt(pycurl.CUSTOMREQUEST, "PUT")
        return self.perform(curl)
    def delete(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.CUSTOMREQUEST, "DELETE")
        return self.perform(curl)
    def options(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.CUSTOMREQUEST, "OPTIONS")
        buffer = StringIO.StringIO()
        curl.setopt(curl.HEADERFUNCTION, buffer.write)
        result = self.perform(curl)

        allows = None
        for line in buffer.getvalue().split("\n"):
            if line.startswith("Allow:"):
                allows = line

        if allows is None:
            result.validationFailure("ERROR: Could not find Allow response")
        else:
            result.diagnostic(allows)

        return result
    def move(self, source, destination):
        curl = self.getcurl(source)
        curl.setopt(pycurl.CUSTOMREQUEST, "MOVE")
        curl.setopt(pycurl.HTTPHEADER, ["Destination: {0}".format(destination)])
        return self.perform(curl)
    def head(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.NOBODY, 1)
        return self.perform(curl)
    def propfind(self, target):
        curl = self.getcurl(target)
        curl.setopt(pycurl.CUSTOMREQUEST, "PROPFIND")
        return self.perform(curl)
    def get(self, target):
        curl = self.getcurl(target)
        buffer = StringIO.StringIO()
        curl.setopt(curl.WRITEFUNCTION, buffer.write)

        result = self.perform(curl)
        if buffer.getvalue() != __TEST_FILE__:
            result.validationFailure("ERROR: The file downloaded not the same as the file uploaded!")
        return result
    def perform(self, curl):
        try:
            curl.perform()
        except Exception, e:
            print("Exception: " + str(e))
        finally:
            status = curl.getinfo(pycurl.HTTP_CODE)
            elapsed = curl.getinfo(pycurl.TOTAL_TIME)
            result = TestResult(status, elapsed)

            return result

# might remain unused
def filterhost(h):
    if "://" in h:
        h = h[h.find("://")+3:]
    if "/" in h:
        h = h[:h.find("/")]
    if ":" in h:
        self.port = h[h.find(":")+1:]
        h = h[:h.find(":")]

def main():
    args = getargs()
    logger = functools.partial(log, threshold=args.verbosity)
    tester = CurlTester(args, logger)
    return tester.test()

if __name__ == "__main__":
    sys.exit(main())
